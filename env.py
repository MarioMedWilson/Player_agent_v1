import gymnasium as gym
import pygame
from gymnasium import spaces
import numpy as np

import seaborn as sns
import matplotlib.pyplot as plt
import sympy
from collections import OrderedDict
import math
import sys
import time

class Player(gym.Env):
    """
    Plays the levels generated by the Generator to validate them
    """

    def __init__(self, size=5, preset_level=None):
        self.size = size
        self.preset_level = preset_level
        self.prime_percent = 0.3
        self.prime_range = self.max = 5
        self.log = ""
        self.observation_space = spaces.Dict({
            "board": spaces.Box(0, 100, shape=(self.size, self.size), dtype=int),
            "player_pos": spaces.Box(0, self.size, shape=(2,), dtype=int),
            "player_prev_pos": spaces.Box(0, self.size, shape=(2,), dtype=int),
            "current_number": spaces.Discrete(100),
            "lives": spaces.Box(0, 10, shape=(1,), dtype=int),
            "remaining_number_of_primes": spaces.Box(0, 100, shape=(1,), dtype=int),
            "goal_prime_number": spaces.Discrete(100),
            "goal_prime_number_pos": spaces.Box(0, self.size, shape=(2,), dtype=int),
            "distance_to_nearest_prime_number": spaces.Box(0, 100, shape=(1,), dtype=int),
            "prev_distance_to_nearest_prime_number": spaces.Box(0, 100, shape=(1,), dtype=int),
            "eat_prime": spaces.Discrete(2),
        })

        self.action_space = spaces.Discrete(5)
        self.max_move = 10000
        self.num_move = 0
        self.action = -1

    def _get_obs(self):
      self.current_state = self.observation_space.sample()
      self.current_state['board'] = np.array([self.board])
      self.current_state['player_pos'] = np.array([self.player_pos])
      self.current_state['player_prev_pos'] = np.array([self.player_prev_pos])
      self.current_state['current_number'] = np.array([self.current_number])
      self.current_state['lives'] = np.array([self.remaining_lives])
      self.current_state['remaining_number_of_primes'] = np.array([self.remaining_number_of_primes])
      self.current_state['goal_prime_number'] = self.goal_prime_number
      self.current_state['goal_prime_number_pos'] = np.array(self.goal_prime_number_pos)
      self.current_state['distance_to_nearest_prime_number'] = np.array([self.distance_to_nearest_prime_number])
      self.current_state['prev_distance_to_nearest_prime_number'] = np.array([self.prev_distance_to_nearest_prime_number])
      self.current_state['eat_prime'] = np.array([self.eat_prime])
      return self.current_state

    def reset(self, seed=None, options=None):
        self.log = ""
        self.board, self.prime_numbers = self.gen_board()
        self.player_pos = np.array([0, 4])  # X, Y
        self.player_prev_pos = np.array([0, 4])  # X, Y
        self.current_number = self.board[self.player_pos[0]][self.player_pos[1]]
        self.remaining_number_of_primes = int(self.size * self.size * self.prime_percent)
        self.remaining_lives = 10
        self.eat_prime = 0
        
        nearest_prime_number, nearest_prime_number_pos = self.find_nearest_prime_number(self.board, self.player_pos, self.prime_numbers)
        self.goal_prime_number = nearest_prime_number
        self.goal_prime_number_pos = nearest_prime_number_pos
        self.distance_to_nearest_prime_number = self.calculate_manhattan_distance(self.player_pos, nearest_prime_number_pos)
        self.prev_distance_to_nearest_prime_number = self.distance_to_nearest_prime_number.copy()
        self.num_move = 0

        observation = self._get_obs()
        info = {}

        return observation, info

    def step(self, action):
        """
        Rewards need to tie in lives, whether the level is won or lost and whether
        the number eaten is good or bad
        """
        self.num_move += 1
        self.log = f"Action {action}, "
        info = {}
        self.action = action
        self.player_prev_pos = self.player_pos.copy()
        self.prev_distance_to_nearest_prime_number = self.distance_to_nearest_prime_number.copy()
        if action == 0 and self.player_pos[1] < 4: # Right
          self.player_pos[1] += 1
          self.current_number = self.board[self.player_pos[0]][self.player_pos[1]]
          self.log += f"Went Right in state {[self.player_pos[0], self.player_pos[1]-1]}, got to state {self.player_pos}"
          if sympy.isprime(self.current_number):
              self.eat_prime = 1
          else:
              self.eat_prime = 0
        elif action == 1 and self.player_pos[1] > 0: # Left
          self.player_pos[1] -= 1
          self.log += f"Went Left in state {[self.player_pos[0], self.player_pos[1]+1]}, got to state {self.player_pos}"
          self.current_number = self.board[self.player_pos[0]][self.player_pos[1]]
          if sympy.isprime(self.current_number):
              self.eat_prime = 1
          else:
              self.eat_prime = 0
        
        elif action == 2: # Eat
          self.log += f"Eat {self.current_number}"
          self.eat()
        
        elif action == 3 and self.player_pos[0] < 4: # Down
          self.player_pos[0] += 1
          self.current_number = self.board[self.player_pos[0]][self.player_pos[1]]
          self.log += f"Went Down in state {[self.player_pos[0]-1, self.player_pos[1]]}, got to state {self.player_pos}"
          if sympy.isprime(self.current_number):
              self.eat_prime = 1
          else:
              self.eat_prime = 0

        elif action == 4 and self.player_pos[0] > 0: # Up
          self.player_pos[0] -= 1
          self.current_number = self.board[self.player_pos[0]][self.player_pos[1]]
          self.log += f"Went Up in state {[self.player_pos[0]+1, self.player_pos[1]]}, got to state {self.player_pos}"
          if sympy.isprime(self.current_number):
              self.eat_prime = 1
          else:
              self.eat_prime = 0

        
        if (action in [0, 1, 3, 4]) and (self.player_prev_pos == self.player_pos).all():
          info['player_pos'] = self.player_pos
          info['player_prev_pos'] = self.player_prev_pos

        if not self.remaining_number_of_primes and self.max != 100:
          self.max += 5

        max_n = self.max
        if self.remaining_lives == 0:
          self.max = 5
        
        self.distance_to_nearest_prime_number = self.calculate_manhattan_distance(self.player_pos, self.goal_prime_number_pos)
        if (self.distance_to_nearest_prime_number < self.prev_distance_to_nearest_prime_number):
          info['distance_to_nearest_prime_number'] = 0

        if self.remaining_lives == 0:
          info['lives'] = 0
        
        if self.remaining_number_of_primes == 0:
          info['remaining_number_of_primes'] = 0
        
        total_reward = self.calculate_rewards(action)
        terminated = not self.remaining_lives or not self.remaining_number_of_primes
        obs = self._get_obs()

        return obs, total_reward, terminated, False, info


    def gen_board(self):
        prime_numbers = list(sympy.primerange(1, self.prime_range + 1))

        possible_non_primes = np.arange(1, self.max)
        non_prime_numbers = possible_non_primes[~np.isin(possible_non_primes, prime_numbers)]

        number_of_primes = int(self.prime_percent * self.size * self.size)
        prime_cells = np.random.choice(prime_numbers, number_of_primes, replace=True)

        number_of_non_primes = (self.size * self.size) - number_of_primes
        non_prime_cells = np.random.choice(non_prime_numbers, number_of_non_primes, replace=True)

        board = np.append(prime_cells, non_prime_cells)
        np.random.shuffle(board)
        board = np.reshape(board, (self.size, self.size))

        return board, prime_numbers

    def eat(self):
        if sympy.isprime(self.current_number):
            self.eat_prime = 1
            if self.remaining_number_of_primes > 0:
                self.remaining_number_of_primes -= 1
        else:
            if self.remaining_lives > 0:
                self.remaining_lives -= 1

        self.board[self.player_pos[0]][self.player_pos[1]] = 0
        self.current_number = 0
        if self.remaining_number_of_primes > 0:
          # Calculate the distance to the nearest prime number.
          nearest_prime_number, nearest_prime_number_pos = self.find_nearest_prime_number(
              self.board,
              self.player_pos,
              self.prime_numbers)
          if nearest_prime_number_pos is None:
            self.distance_to_nearest_prime_number = math.inf
          else:
            self.goal_prime_number = nearest_prime_number
            self.goal_prime_number_pos = nearest_prime_number_pos
            self.distance_to_nearest_prime_number = self.calculate_manhattan_distance(
                self.player_pos,
                nearest_prime_number_pos)


    def calculate_rewards(self, action):
        total_reward = 0
        if self.remaining_lives == 0:
            total_reward -= 3

        if self.remaining_number_of_primes == 0 and self.remaining_lives == 10:
            total_reward += 10

        elif self.remaining_number_of_primes == 0 and self.remaining_lives >= 5:
            total_reward += 7
        
        elif self.remaining_number_of_primes == 0 and self.remaining_lives >= 1:
            total_reward += 3

        if self.eat_prime == 1 and action == 2:
            total_reward += 4

        if self.eat_prime == 1 and action != 2:
            total_reward -= 3

        if self.eat_prime == 0 and action == 2:
            total_reward -= 4

        if (self.distance_to_nearest_prime_number < self.prev_distance_to_nearest_prime_number):
          total_reward += 1
        if self.distance_to_nearest_prime_number > self.prev_distance_to_nearest_prime_number:
          total_reward -= 1
        
        if np.all(self.player_prev_pos == self.player_pos) and np.any(action in [0, 1, 3, 4]):
          total_reward -= 2

        return total_reward

    def calculate_manhattan_distance(self, start_pos, end_pos):
      """
      Calculates the Manhattan distance between two positions on the board.

      Args:
        start_pos: The starting position.
        end_pos: The ending position.

      Returns:
        The Manhattan distance between the two positions.
      """
      x1, y1 = start_pos
      x2, y2 = end_pos
      dist = abs(x1 - x2) + abs(y1 - y2)
      return dist

    def find_nearest_prime_number(self, board, start_pos, prime_numbers):
      """
      Finds the nearest prime number on the board using the A* algorithm.

      Args:
      board: The board with the numbers.
      start_pos: The starting position.
      prime_numbers: A list of prime numbers.

      Returns:
      The nearest prime number on the board and its position.
      """

      # Create a priority queue to store the positions to be explored.
      priority_queue = []
      # Add the starting position to the priority queue.
      priority_queue.append((self.calculate_manhattan_distance(start_pos, (0, 0)), start_pos))

      # Create a set to store the visited positions.
      visited = set()

      # While the priority queue is not empty, continue searching.
      while priority_queue:
        # Get the position with the smallest distance from the priority queue.
        current_pos = priority_queue.pop(0)[1]

        # If the position has already been visited, skip it.
        if tuple(current_pos) in visited:
          continue

        # Add the position to the set of visited positions.
        visited.add(tuple(current_pos))

        # If the number at the position is a prime number, return it.
        if board[current_pos[0]][current_pos[1]] in prime_numbers:
          return board[current_pos[0]][current_pos[1]], current_pos

        # Iterate over the neighbors of the position.
        for neighbor_pos in [(current_pos[0] + 1, current_pos[1]), (current_pos[0] - 1, current_pos[1]),
                            (current_pos[0], current_pos[1] + 1), (current_pos[0], current_pos[1] - 1)]:

          # If the neighbor position is valid and has not been visited, add it to the priority queue.
          if 0 <= neighbor_pos[0] < self.size and 0 <= neighbor_pos[1] < self.size and neighbor_pos not in visited:
            # Calculate the Manhattan distance between the neighbor position and the ending position.
            distance = self.calculate_manhattan_distance(neighbor_pos, (0, 0))

            # Add the neighbor position to the priority queue with the distance as the key.
            priority_queue.append((distance, neighbor_pos))

      # If no prime number was found, return None.
      return None, None


    def render(self):
      print(self.log)
      pygame.init()
      self.screen_size = (600, 700)
      self.screen = pygame.display.set_mode(self.screen_size)
      pygame.display.set_caption('Your Game')
      cell_size = self.screen_size[0] // len(self.board[0])

      # Display lives bar
      lives_bar_width = self.remaining_lives * 30  # Adjust the width based on the number of lives
      pygame.draw.rect(self.screen, (255, 0, 0), (0, 0, lives_bar_width, 20))

      # Display remaining primes bar
      primes_bar_width = self.remaining_number_of_primes * 30  # Adjust the width based on the remaining number of primes
      pygame.draw.rect(self.screen, (0, 255, 0), (0, 30, primes_bar_width, 20))

      # Display board
      for i in range(len(self.board)):
          for j in range(len(self.board[0])):
              pygame.draw.rect(self.screen, (255, 0, 255), (j * cell_size, i * cell_size + 60, cell_size, cell_size), 2)
              number = str(self.board[i][j])
              font = pygame.font.Font(None, 36)
              text = font.render(number, True, (255, 0, 0))
              text_rect = text.get_rect(center=(j * cell_size + cell_size // 2, i * cell_size + cell_size // 2 + 60))
              self.screen.blit(text, text_rect)

      player_size = cell_size // 3
      player_pos = (self.player_pos[1] * cell_size + cell_size // 2, self.player_pos[0] * cell_size + cell_size // 2 + 60)

      if self.action != 2:
        # Draw a transparent circle with a hole to see the number behind
        self.draw_transparent_circle(self.screen, (0, 0, 255, 128), player_pos, player_size)
      else:
        # Draw a transparent circle with a hole and display "Eat" text
        self.draw_transparent_circle(self.screen, (0, 255, 0, 128), player_pos, player_size)
        font = pygame.font.Font(None, 36)
        text = font.render("Eat", True, (255, 255, 255))
        text_rect = text.get_rect(center=player_pos)
        self.screen.blit(text, text_rect)

      pygame.display.flip()

      clock = pygame.time.Clock()
    
    def draw_transparent_circle(self, surface, color, position, size):
        # Create a transparent surface with an alpha channel
        transparent_surface = pygame.Surface((2*size, 2*size), pygame.SRCALPHA)
        pygame.draw.circle(transparent_surface, color, (size, size), size)
        # Blit the transparent surface onto the main surface
        surface.blit(transparent_surface, (position[0] - size, position[1] - size))


    # ... existing code ...





# Pl = Player()
# state, info = Pl.reset()
# print(state)
# Pl.render()
# time.sleep(1)
# state, reward, done, clipped, info = Pl.step(2)
# Pl.render()
# time.sleep(1)
# state, reward, done, clipped, info = Pl.step(1)
# Pl.render()
# time.sleep(1)
# state, reward, done, clipped, info = Pl.step(3)
# Pl.render()
# time.sleep(1)
# state, reward, done, clipped, info = Pl.step(2)
# Pl.render()
# time.sleep(1)
# state, reward, done, clipped, info = Pl.step(1)
# Pl.render()
# time.sleep(1)
# state, reward, done, clipped, info = Pl.step(4)
# Pl.render()

# nearest_prime_number, nearest_prime_number_pos = Pl.find_nearest_prime_number(Pl.board, Pl.player_pos, Pl.prime_numbers)
# print("Nearest prime number: ", nearest_prime_number)
# print("Nearest prime number position: ", nearest_prime_number_pos)
# distance = Pl.calculate_manhattan_distance(Pl.player_pos, nearest_prime_number_pos)
# print("Distance: ", distance)
import gymnasium as gym
import pygame
from gymnasium import spaces
import numpy as np
from stable_baselines3 import DQN

import seaborn as sns
import matplotlib.pyplot as plt
import sympy
from collections import OrderedDict


class Player(gym.Env):
    """
    Plays the levels generated by the Generator to validate them
    """

    def __init__(self, size=5, preset_level=None):
        self.size = size
        self.preset_level = preset_level
        self.prime_percent = 0.3
        self.prime_range = self.max = 5
        self.log = ""

        self.observation_space = spaces.Dict({
            "board": spaces.Box(0, 100, shape=(self.size, self.size), dtype=int),
            "player_pos": spaces.Box(0, self.size, shape=(2,), dtype=int),
            "current_number": spaces.Discrete(100),
            "lives": spaces.Box(0, 10, shape=(1,), dtype=int),
            "remaining_number_of_primes": spaces.Box(0, 100, shape=(1,), dtype=int)
        })

        self.action_space = spaces.Discrete(5)

    def _get_obs(self):
      self.current_state = self.observation_space.sample()
      self.current_state['board'] = np.array([self.board])
      self.current_state['player_pos'] = np.array([self.player_pos])
      self.current_state['current_number'] = np.array([self.current_number])
      self.current_state['remaining_number_of_primes'] = np.array([self.remaining_number_of_primes])
      self.current_state['lives'] = np.array([self.remaining_lives])

      return self.current_state

    def reset(
            self,
            seed=None,
            options=None,
    ):
        self.board = self.gen_board()
        self.player_pos = np.array([0, 4])  # X, Y
        self.current_number = self.board[self.player_pos[0]][self.player_pos[1]]
        self.remaining_number_of_primes = int(self.size * self.size * self.prime_percent)
        self.remaining_lives = 10

        observation = self._get_obs()
        info = {}

        return observation, info

    def step(self, action):
        """
        Rewards need to tie in lives, whether the level is won or lost and whether
        the number eaten is good or bad
        """
        self.was_prime = False
        if action == 0 and self.player_pos[1] < 4: # UP
            self.player_pos[1] += 1
            self.log = f"Went UP in state {self.player_pos[1]-1}, got to state {self.player_pos}"
        elif action == 1 and self.player_pos[1] > 0: # Down
            self.player_pos[1] -= 1
            self.log = f"Went Down in state {self.player_pos[1]+1}, got to state {self.player_pos}"
        elif action == 2: # Eat
            self.eat()
            self.log = f"Eat"
        elif action == 3 and self.player_pos[0] < 4: # Right
            self.player_pos[0] += 1
            self.log = f"Went Right in state {self.player_pos[0]-1}, got to state {self.player_pos}"
        elif action == 4 and self.player_pos[0] > 0: # Left
            self.player_pos[0] -= 1
            self.log = f"Went Left in state {self.player_pos[0]+1}, got to state {self.player_pos}"

        self.current_number = self.board[self.player_pos[0]][self.player_pos[1]]

        if not self.remaining_number_of_primes and self.max != 100:
            self.max += 5

        max_n = self.max
        if self.remaining_lives == 0:
            self.max = 5

        total_reward = self.calculate_rewards(action)
        terminated = not self.remaining_lives or not self.remaining_number_of_primes
        obs = self._get_obs()
        info = {}

        # PC modification
        # if terminated:
        #     print(f"Level: Terminated, Remaining Lives: {self.remaining_lives}, "
        #           f"Remaining Primes: {self.remaining_number_of_primes}, ")
        #     self.reset()

        return obs, total_reward, terminated, False, info


    def gen_board(self):
        prime_numbers = list(sympy.primerange(1, self.prime_range + 1))

        possible_non_primes = np.arange(1, self.max)
        non_prime_numbers = possible_non_primes[~np.isin(possible_non_primes, prime_numbers)]

        number_of_primes = int(self.prime_percent * self.size * self.size)
        prime_cells = np.random.choice(prime_numbers, number_of_primes, replace=True)

        number_of_non_primes = (self.size * self.size) - number_of_primes
        non_prime_cells = np.random.choice(non_prime_numbers, number_of_non_primes, replace=True)

        board = np.append(prime_cells, non_prime_cells)
        np.random.shuffle(board)
        board = np.reshape(board, (self.size, self.size))

        return board

    def eat(self):
        if sympy.isprime(self.current_number):
            self.was_prime = True
            if self.remaining_number_of_primes > 0:
                self.remaining_number_of_primes -= 1
        else:
            if self.remaining_lives > 0:
                self.remaining_lives -= 1

        self.board[self.player_pos[0]][self.player_pos[1]] = 0

    def calculate_rewards(self, action):
        total_reward = 0
        if self.remaining_lives == 0:
            total_reward -= 30

        if self.remaining_number_of_primes == 0:
            total_reward += 50

        if self.was_prime and action == 2:
            total_reward += 25

        if self.was_prime and action != 2:
            total_reward -= 20

        if not self.was_prime and action == 2:
            total_reward -= 15

        return total_reward

    def render(self):
      print(self.log)
      pass


Pl = Player()
Pl.reset()
